# This refreshes the cloud infrastructure (builds a new vm)
# It then connects to the VM via SSH and configures everything (installs docker, pulls container images, injects secrets)
# Finally it sets up security (revokes SSH access and puts VM behind Wireguard) and brings up all the containers

name: Deploy

on:
  workflow_run:
    workflows: [Build]
    types: [completed]

env:
  REGISTRY: ghcr.io # the github container registry
  IMAGE_NAME: ${{ github.repository }} # github.repository as <account>/<repo> i.e. danny-baker/atlas

jobs:

  on-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - run: echo 'The triggering build workflow failed'

  on-success:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:

     # Checkout code (needed to access bicep file)
    - uses: actions/checkout@main
     
      # Log into Azure
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Tear down azure resources (if existing)
      #if: ${{ false }} # set false (or comment this line) to skip this task TODO improve logic
      uses: azure/CLI@v1
      env:
        RESOURCE_GROUP_NAME: ${{ vars.AZURE_RG }}
        RESOURCE_GROUP_LOCATION: ${{ vars.AZURE_RG_LOCN }}
        VM_PROJECT_NAME: ${{ vars.AZURE_VM_PROJECT_NAME }} 
        VM_NIC: "${{ vars.AZURE_VM_PROJECT_NAME }}-nic"
        VM_IP: "${{ vars.AZURE_VM_PROJECT_NAME }}-ip"
        VM_NSG: "${{ vars.AZURE_VM_PROJECT_NAME }}-nsg"
        VM_NAME: "${{ vars.AZURE_VM_PROJECT_NAME }}-vm"
        VM_VNET: "${{ vars.AZURE_VM_PROJECT_NAME }}-VNet"
        VM_DISK: "${{ vars.AZURE_VM_PROJECT_NAME }}-disk"

      with:
        azcliversion: 2.30.0
        inlineScript: |
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_NAME --resource-type "Microsoft.Compute/virtualMachines"
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_NIC --resource-type "Microsoft.Network/networkInterfaces"
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_NSG --resource-type "Microsoft.Network/networkSecurityGroups"
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_IP --resource-type "Microsoft.Network/publicIPAddresses"
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_VNET --resource-type "Microsoft.Network/virtualNetworks"
          az resource delete -g $RESOURCE_GROUP_NAME -n $VM_DISK --resource-type "Microsoft.Compute/disks"

      # Deploy Bicep file
    - name: Deploy VM with bicep file
      uses: azure/arm-deploy@v1
      with:
        subscriptionId: ${{ vars.AZURE_SUBSCRIPTION }}
        resourceGroupName: ${{ vars.AZURE_RG }}
        template: ./infrastructure/azure-deploy/create-vm.bicep
        parameters: adminUsername="${{ secrets.AZURE_VM_USERNAME }}" adminPublicKey="${{ secrets.AZURE_VM_SSHPUBKEY }}" vmModel="${{ secrets.AZURE_VM_MODEL }}" osDiskSize=${{ secrets.AZURE_VM_DISK_SIZE_GB }} osDiskType="${{ secrets.AZURE_VM_DISK_TYPE }}" projectName="${{ secrets.AZURE_VM_PROJECT_NAME }}" ipConfig="${{ secrets.AZURE_VM_IPCONFIG }}"
        failOnStdErr: false

    - name: Associate the static IP with the VM's NIC 
      uses: azure/CLI@v1
      env:
        RESOURCE_GROUP_NAME: ${{ vars.AZURE_RG }} 
        VM_NIC: "${{ vars.AZURE_VM_PROJECT_NAME }}-nic"
        VM_IPCONFIG: ${{ vars.AZURE_VM_IPCONFIG }}
        VM_STATIC_IP: ${{ vars.AZURE_VM_STATIC_IP }} #this is the literal IP address resource name in Azure portal (it need not be a secret handle)
      
      with:
        azcliversion: 2.30.0
        inlineScript: |
          az network nic ip-config update --name $VM_IPCONFIG --nic-name $VM_NIC --resource-group $RESOURCE_GROUP_NAME --public-ip-address $VM_STATIC_IP

      # Setup github and clone repo to new vm (server)
    - name: ssh to server, setup github keys and clone repo
      uses: appleboy/ssh-action@master
      env:
          GITHUB_PRIVATE_KEY: ${{ secrets.GHUB_PRIVATE_KEY }}
          GITHUB_PUBLIC_KEY: ${{ secrets.GHUB_PUBLIC_KEY }}
      with:
        host: ${{ vars.AZURE_VM_SSHHOST }}
        username: ${{ vars.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSHPRIVKEY }}
        port: ${{ vars.AZURE_VM_SSH_PORT }}
        envs: GITHUB_PRIVATE_KEY, GITHUB_PUBLIC_KEY
        script: |
          echo "$GITHUB_PRIVATE_KEY" > ~/.ssh/github
          echo "$GITHUB_PUBLIC_KEY" > ~/.ssh/github.pub
          chmod 600 ~/.ssh/github
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/github
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          ssh -T git@github.com
          cd ~
          git clone git@github.com:danny-baker/atlas.git

      # Inject TLS certs (HTTPS)
    - name: ssh to server and obtain TLS certs
      uses: appleboy/ssh-action@master
      env:
          TLS_PRIVKEY: ${{ secrets.TLS_PRIVKEY }}
          TLS_FULLCHAIN: ${{ secrets.TLS_FULLCHAIN }}
      with:
        host: ${{ vars.AZURE_VM_SSHHOST }}
        username: ${{ vars.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSHPRIVKEY }}
        port: ${{ vars.AZURE_VM_SSH_PORT }}
        envs: TLS_PRIVKEY, TLS_FULLCHAIN
        script: |
          echo "$TLS_PRIVKEY" > ~/atlas/infrastructure/certbot/conf/live/worldatlas.org/privkey.pem
          echo "$TLS_FULLCHAIN" > ~/atlas/infrastructure/certbot/conf/live/worldatlas.org/fullchain.pem
          chmod 600 ~/atlas/infrastructure/certbot/conf/live/worldatlas.org/privkey.pem
          chmod 600 ~/atlas/infrastructure/certbot/conf/live/worldatlas.org/fullchain.pem

      # Inject secrets
    - name: ssh to server and inject secrets
      uses: appleboy/ssh-action@master
      env:
          SECRET_DATADOG_API_KEY: ${{ secrets.SECRET_DATADOG_API_KEY }}
          SECRET_EMAIL_FOR_TLS_CERT_GENERATOR: ${{ secrets.SECRET_EMAIL_FOR_TLS_CERT_GENERATOR }}
          SECRET_TAILSCALE_AUTHKEY: ${{ secrets.SECRET_TAILSCALE_AUTHKEY }}

      with:
        host: ${{ vars.AZURE_VM_SSHHOST }}
        username: ${{ vars.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSHPRIVKEY }}
        port: ${{ vars.AZURE_VM_SSH_PORT }}
        envs: SECRET_DATADOG_API_KEY, SECRET_EMAIL_FOR_TLS_CERT_GENERATOR, SECRET_TAILSCALE_AUTHKEY 
        script: |
          sed -i "s/SECRET_DATADOG_API_KEY/$SECRET_DATADOG_API_KEY/" ~/atlas/docker-compose.yml
          sed -i "s/SECRET_EMAIL_FOR_TLS_CERT_GENERATOR/$SECRET_EMAIL_FOR_TLS_CERT_GENERATOR/" ~/atlas/startup-generate-certs.sh
          sed -i "s/SECRET_TAILSCALE_AUTHKEY/$SECRET_TAILSCALE_AUTHKEY/" ~/atlas/infrastructure/azure-deploy/setup-vm.sh
          echo "Secrets injected."
      
      # Install services (Docker, docker-compose)
    - name: ssh to server and setup services (docker, docker-compose)
      uses: appleboy/ssh-action@master
      with:
        host: ${{ vars.AZURE_VM_SSHHOST }}
        username: ${{ vars.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSHPRIVKEY }}
        port: ${{ vars.AZURE_VM_SSH_PORT }}
        script: . ~/atlas/infrastructure/azure-deploy/setup-vm.sh

      # Bring up app
    - name: Bring up the app
      uses: appleboy/ssh-action@master
      env:
        GHUB_TOKEN: ${{ secrets.GHUB_TOKEN }}
      with:
        host: ${{ vars.AZURE_VM_SSHHOST }}
        username: ${{ vars.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSHPRIVKEY }}
        port: ${{ vars.AZURE_VM_SSH_PORT }}
        envs: GHUB_TOKEN
        script: |
          echo "Logging into github container registry"
          echo $GHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
          echo "Starting up NOW"
          cd ~/atlas
          . startup-manual-certs.sh

      # Revoke public SSH access
    - name: Revoke SSH public access (most be via tailnet)
      uses: azure/CLI@v1
      env:
        RESOURCE_GROUP_NAME: ${{ vars.AZURE_RG }}
        VM_NSG: "${{ vars.AZURE_VM_PROJECT_NAME }}-nsg"

      with:
        azcliversion: 2.30.0
        inlineScript: |
          az network nsg rule update --name SSH --nsg-name $VM_NSG --resource-group $RESOURCE_GROUP_NAME --access Deny
